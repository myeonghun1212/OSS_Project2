# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15i_zvtPcO_noRYXJKdT4G4ZXCvl8Lk4e
"""
"""
# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')

FOLDERNAME = 'OSSProject2'
assert FOLDERNAME is not None, "[!] Enter the foldername."

import sys
sys.path.append('/content/drive/MyDrive/{}'.format(FOLDERNAME))
# %cd /content/drive/MyDrive/$FOLDERNAME
# %ls

#데이터 설치
!pip install matplotlib
!pip install scikit-learn
!pip install pandas
!pip install numpy
"""

import pandas as pd
import numpy as np

ratings_data = pd.read_csv('ratings.dat', sep='::', header=None, names=['user_id', 'movie_id', 'rating', 'timestamp'],engine='python')

user_item_matrix = ratings_data.pivot_table('rating', index='user_id', columns='movie_id')

ids = list(range(1, 3953))

user_item_matrix = user_item_matrix.reindex(columns=ids)

user_item_matrix = user_item_matrix.fillna(0)

from sklearn.cluster import KMeans
kmeans = KMeans(n_clusters = 3, random_state = 42)
kmeans.fit(user_item_matrix)

labels = kmeans.predict(user_item_matrix)

# 각 유저의 클러스터 레이블 확인
user_groups = pd.DataFrame({'user_id': ratings_data['user_id'].unique(), 'group': labels})

user_item_matrix = user_item_matrix.astype(np.uint8)

def get_user_item_matrix_by_group(user_item_matrix, user_groups, group_id):
    group_users = user_groups[user_groups['group'] == group_id]['user_id']
    group_matrix = user_item_matrix.loc[group_users]
    return group_matrix

def AU(group_matrix):
    return np.sum(group_matrix, axis=0)

def Avg(group_matrix):
    return np.mean(group_matrix, axis=0)

def SC(group_matrix):
    return group_matrix[group_matrix > 0].count(axis=0)

def AV(group_matrix):
    return group_matrix[group_matrix >=4].count(axis=0)

def BC(group_matrix):
    res = pd.DataFrame(columns = group_matrix.columns)
    for i in group_matrix.index:
        temp = group_matrix.loc[i]
        temp = temp.rank(method='average') - 1
        res.loc[i] = temp
    return res.sum(axis = 0)

def BC_Optimized(group_matrix):
    return group_matrix.rank(method='average', axis=1).sum(axis=0) - group_matrix.shape[0]

def CR(group_matrix):
    n = 100
    res = pd.DataFrame(index=group_matrix.columns[:n], columns=group_matrix.columns[:n], dtype=float)
    for i in group_matrix.columns[:n]:
        for j in group_matrix.columns[:n]:
            if i == j:
                continue
            g = (group_matrix[i] > group_matrix[j]).value_counts().get(True, 0)
            l = (group_matrix[i] < group_matrix[j]).value_counts().get(True, 0)
            if g > l:
                res.at[i,j] = 1
            elif g == l:
                res.at[i,j] = 0
            else:
                res.at[i,j] = -1
    return res.sum(axis=0)

def CR_Optimized(group_matrix):
    n = len(group_matrix.columns)
    # n = 1000
    nparr = group_matrix.T.values
    res = np.zeros((n,n))
    idx_upper = np.triu_indices(n, k = 1)
    for i in range(n):
        for j in range(i+1, n):
            res[i,j] = (nparr[i] > nparr[j]).sum()
            res[j,i] = (nparr[i] < nparr[j]).sum()
    #
    return pd.Series(  np.sign(res - res.T).sum(axis = 0), index = group_matrix.columns[:n])

def CR_Optimized2(group_matrix):
    n = len(group_matrix.columns)
    # n = 1000
    nparr = group_matrix.T.values
    res = np.zeros((n,n))
    idx_upper = np.triu_indices(n, k=1)
    res[idx_upper] = (nparr[idx_upper[0]] > nparr[idx_upper[1]]).sum(axis = 1)
    res.T[idx_upper] = (nparr[idx_upper[0]] < nparr[idx_upper[1]]).sum(axis = 1)
    result = pd.Series(  np.sign(res - res.T).sum(axis = 0), index = group_matrix.columns[:n])
    del nparr, res, idx_upper
    return result

def CR_Optimized2_Sub(group_matrix, res, idx_upper):
    n = len(group_matrix.columns)
    res[idx_upper] += (group_matrix.T.values[idx_upper[0]] > group_matrix.T.values[idx_upper[1]]).sum(axis = 1)
    res.T[idx_upper] += (group_matrix.T.values[idx_upper[0]] < group_matrix.T.values[idx_upper[1]]).sum(axis = 1)

def CR_Optimized2_Chunk(group_matrix):
    n = len(group_matrix.columns)
    idx_upper = np.triu_indices(n, k=1)
    res = np.zeros((n,n), dtype = np.int16)
    total = len(group_matrix.index)
    chunk_size = 1000 # colab tpu 같이 용량 큰데서 이정도면 돌아감
    # chunk_size = 100 # 데스크탑 램에서 돌아갈 사이즈
    for start in range(0, total, chunk_size):
        end = min(start + chunk_size, total)
        # print(start, end)
        subgroup = group_matrix.iloc[start:end, :]
        CR_Optimized2_Sub(subgroup, res, idx_upper)
        del subgroup

    result = pd.Series(  np.sign(res - res.T).sum(axis = 0), index = group_matrix.columns)
    del res
    return result

def printList(series):
    for i, v in enumerate(series):
        print(f'{i+1}. {v}')

for groupnumber in range(3):
  group = get_user_item_matrix_by_group(user_item_matrix, user_groups, groupnumber)
  additiveUtilitarian = AU(group)
  average = Avg(group)
  simpleCount = SC(group)
  approvalVoting = AV(group)
  bordaCount = BC_Optimized(group)
  copelandRule = CR_Optimized2_Chunk(group)
  print(f"top 10 mvoies of group {groupnumber} using Additive Utilitarian")
  printList(additiveUtilitarian.nlargest(10).index)
  print(f"top 10 mvoies of group {groupnumber} using Average")
  printList(average.nlargest(10).index)
  print(f"top 10 mvoies of group {groupnumber} using Simple Count")
  printList(simpleCount.nlargest(10).index)
  print(f"top 10 mvoies of group {groupnumber} using Approval Voting")
  printList(approvalVoting.nlargest(10).index)
  print(f"top 10 mvoies of group {groupnumber} using Borda Count")
  printList(bordaCount.nlargest(10).index)
  print(f"top 10 mvoies of group {groupnumber} using Copeland Rule")
  printList(copelandRule.nlargest(10).index)